Index: plugin.video.specto/addon.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/addon.xml	(revision )
+++ plugin.video.specto/addon.xml	(revision )
@@ -6,6 +6,8 @@
 		<import addon="script.module.metahandler" />
 		<import addon="plugin.video.youtube" optional="true" />
 
+        <import addon="script.module.pydevd" version="3.4.1"/>
+
 	</requires>
 	<extension point="xbmc.python.pluginsource" library="default.py">
 		<provides>video</provides>
Index: plugin.video.specto/resources/lib/indexers/movies.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/indexers/movies.py	(revision )
+++ plugin.video.specto/resources/lib/indexers/movies.py	(revision )
@@ -51,7 +51,7 @@
         self.month2_date = (self.datetime - datetime.timedelta(days = 60)).strftime('%Y-%m-%d')
         self.year_date = (self.datetime - datetime.timedelta(days = 365)).strftime('%Y-%m-%d')
         self.year_date10 = (self.datetime - datetime.timedelta(days = 3650)).strftime('%Y-%m-%d')
-        self.trakt_user = control.setting('trakt_user')
+        self.trakt_user = control.setting('trakt.user')
         self.imdb_user = control.setting('imdb_user').replace('ur', '')
         self.info_lang = control.setting('infoLang') or 'en'
 
@@ -71,41 +71,6 @@
         #self.certifications_link = 'http://api.themoviedb.org/3/certification/movie/list?api_key=%s' % self.tmdb_key
 
         """
-        <table>
-<tr><td><input id="genres-1" type="checkbox" name="genres" value="action" > <label for="genres-1">Action</label></td>
-<td><input id="genres-2" type="checkbox" name="genres" value="adventure" > <label for="genres-2">Adventure</label></td>
-<td><input id="genres-3" type="checkbox" name="genres" value="animation" > <label for="genres-3">Animation</label></td>
-<td><input id="genres-4" type="checkbox" name="genres" value="biography" > <label for="genres-4">Biography</label></td>
-</tr>
-<tr><td><input id="genres-5" type="checkbox" name="genres" value="comedy" > <label for="genres-5">Comedy</label></td>
-<td><input id="genres-6" type="checkbox" name="genres" value="crime" > <label for="genres-6">Crime</label></td>
-<td><input id="genres-7" type="checkbox" name="genres" value="documentary" > <label for="genres-7">Documentary</label></td>
-<td><input id="genres-8" type="checkbox" name="genres" value="drama" > <label for="genres-8">Drama</label></td>
-</tr>
-<tr><td><input id="genres-9" type="checkbox" name="genres" value="family" > <label for="genres-9">Family</label></td>
-<td><input id="genres-10" type="checkbox" name="genres" value="fantasy" > <label for="genres-10">Fantasy</label></td>
-<td><input id="genres-11" type="checkbox" name="genres" value="film_noir" > <label for="genres-11">Film-Noir</label></td>
-<td><input id="genres-12" type="checkbox" name="genres" value="game_show" > <label for="genres-12">Game-Show</label></td>
-</tr>
-<tr><td><input id="genres-13" type="checkbox" name="genres" value="history" > <label for="genres-13">History</label></td>
-<td><input id="genres-14" type="checkbox" name="genres" value="horror" > <label for="genres-14">Horror</label></td>
-<td><input id="genres-15" type="checkbox" name="genres" value="music" > <label for="genres-15">Music</label></td>
-<td><input id="genres-16" type="checkbox" name="genres" value="musical" > <label for="genres-16">Musical</label></td>
-</tr>
-<tr><td><input id="genres-17" type="checkbox" name="genres" value="mystery" > <label for="genres-17">Mystery</label></td>
-<td><input id="genres-18" type="checkbox" name="genres" value="news" > <label for="genres-18">News</label></td>
-<td><input id="genres-19" type="checkbox" name="genres" value="reality_tv" > <label for="genres-19">Reality-TV</label></td>
-<td><input id="genres-20" type="checkbox" name="genres" value="romance" > <label for="genres-20">Romance</label></td>
-</tr>
-<tr><td><input id="genres-21" type="checkbox" name="genres" value="sci_fi" > <label for="genres-21">Sci-Fi</label></td>
-<td><input id="genres-22" type="checkbox" name="genres" value="sport" > <label for="genres-22">Sport</label></td>
-<td><input id="genres-23" type="checkbox" name="genres" value="talk_show" > <label for="genres-23">Talk-Show</label></td>
-<td><input id="genres-24" type="checkbox" name="genres" value="thriller" > <label for="genres-24">Thriller</label></td>
-</tr>
-<tr><td><input id="genres-25" type="checkbox" name="genres" value="war" > <label for="genres-25">War</label></td>
-<td><input id="genres-26" type="checkbox" name="genres" value="western" > <label for="genres-26">Western</label></td>
-</table>
-
         self.persons_link = 'http://www.imdb.com/search/name?count=100&name=%s'
         self.personlist_link = 'http://www.imdb.com/search/name?count=100&gender=male,female'
         self.popular_link = 'http://www.imdb.com/search/title?title_type=feature,tv_movie&languages=en&num_votes=1000,&production_status=released&groups=top_1000&sort=moviemeter,asc&count=40&start=1'
@@ -156,6 +121,7 @@
 
 
     def get(self, url, idx=True):
+        control.log("movie url: %s" % url )
         try:
             try: url = getattr(self, url + '_link')
             except: pass
@@ -501,7 +467,7 @@
             next = ''
 
         for item in items:
-            #control.log("##################><><><><> trakt_list item  %s" % item)
+            control.log("##################><><><><> trakt_list item  %s" % item)
 
             try:
                 title = item['title']
Index: plugin.video.specto/resources/lib/indexers/tvshows.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/indexers/tvshows.py	(revision )
+++ plugin.video.specto/resources/lib/indexers/tvshows.py	(revision )
@@ -49,7 +49,7 @@
         self.week_date = (self.datetime - datetime.timedelta(days = 7)).strftime('%Y-%m-%d')
         self.month_date = (self.datetime - datetime.timedelta(days = 30)).strftime('%Y-%m-%d')
         self.year_date = (self.datetime - datetime.timedelta(days = 365)).strftime('%Y-%m-%d')
-        self.trakt_user = control.setting('trakt_user')
+        self.trakt_user = control.setting('trakt.user')
         self.imdb_user = control.setting('imdb_user').replace('ur', '')
         self.info_lang = control.setting('infoLang') or 'en'
 
Index: plugin.video.specto/resources/lib/indexers/episodes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/indexers/episodes.py	(revision )
+++ plugin.video.specto/resources/lib/indexers/episodes.py	(revision )
@@ -537,7 +537,7 @@
         self.datetime = (datetime.datetime.utcnow() - datetime.timedelta(hours = 5))
         self.systime = (self.datetime).strftime('%Y%m%d%H%M%S%f')
         self.today_date = (self.datetime).strftime('%Y-%m-%d')
-        self.trakt_user = control.setting('trakt_user')
+        self.trakt_user = control.setting('trakt.user')
         self.info_lang = control.setting('infoLang') or 'en'
 
         self.tvdb_info_link = 'http://thetvdb.com/api/%s/series/%s/all/%s.zip' % (self.tvdb_key, '%s', '%s')
Index: plugin.video.specto/resources/lib/indexers/navigator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/indexers/navigator.py	(revision )
+++ plugin.video.specto/resources/lib/indexers/navigator.py	(revision )
@@ -24,8 +24,6 @@
 
 
 from resources.lib.libraries import control
-from resources.lib.libraries import trakt_api2
-from resources.lib.libraries import gui_utils
 
 
 
@@ -36,7 +34,7 @@
 try: action = dict(urlparse.parse_qsl(sys.argv[2].replace('?','')))['action']
 except: action = None
 
-traktMode = False if control.setting('trakt_user') == '' else True
+traktMode = False if control.setting('trakt.user') == '' else True
 
 imdbMode = False if control.setting('imdb_user') == '' else True
 
@@ -50,15 +48,17 @@
         tv_library = os.path.join(control.transPath(control.setting('tv_library')),'')
         tv_downloads = os.path.join(control.transPath(control.setting('tv_downloads')),'')
         movie_downloads = os.path.join(control.transPath(control.setting('movie_downloads')),'')
+        try:
-        if not os.path.exists(movie_library):
-            os.makedirs(movie_library)
-        if not os.path.exists(tv_library):
-            os.makedirs(tv_library)
+            if not os.path.exists(movie_library):
+                os.makedirs(movie_library)
+            if not os.path.exists(tv_library):
+                os.makedirs(tv_library)
-        if not os.path.exists(tv_downloads):
+            if not os.path.exists(tv_downloads) and tv_downloads!="":
-            os.makedirs(tv_downloads)
+                os.makedirs(tv_downloads)
-        if not os.path.exists(movie_downloads):
+            if not os.path.exists(movie_downloads) and movie_downloads!="":
-            os.makedirs(movie_downloads)
+                os.makedirs(movie_downloads)
-
+        except:
+            pass
         #if not control.TOKEN:
         #    last_reminder = control.setting('last_reminder')
         #    if last_reminder !='':
@@ -73,8 +73,6 @@
         #    profile = control.traktapi.get_user_profile()
         #    control.set_setting('trakt_user', '%s (%s)' % (profile['username'], profile['name']))
 
-    def trakt_pin_auth(self):
-        gui_utils.get_pin()
 
     def root(self):
         self.addDirectoryItem(30001, 'movieNavigator', 'movies.jpg', 'DefaultMovies.png')
Index: plugin.video.specto/resources/lib/libraries/trakt_copy.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/libraries/trakt_copy.py	(revision )
+++ plugin.video.specto/resources/lib/libraries/trakt_copy.py	(revision )
@@ -0,0 +1,181 @@
+# -*- coding: utf-8 -*-
+
+'''
+    Specto Add-on
+    Copyright (C) 2015 lambda
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+'''
+
+
+import json,urlparse,base64
+
+from resources.lib.libraries import cache
+from resources.lib.libraries import control
+from resources.lib.libraries import client
+
+mytraktkey = control.trakt_key
+
+
+def getTrakt(url, post=None):
+    try:
+        trakt_base = 'http://api-v2launch.trakt.tv'
+        headers = {'Content-Type': 'application/json', 'trakt-api-key': mytraktkey , 'trakt-api-version': '2'}
+        user, password = getTraktCredentials()
+        token = cache.get(authTrakt, 24, urlparse.urljoin(trakt_base, '/auth/login'), json.dumps({'login': user, 'password': password}), headers, table='rel_trakt')
+        headers.update({'trakt-user-login': user, 'trakt-user-token': token})
+    except:
+        pass
+    try:
+        if not post == None: post = json.dumps(post)
+        result = client.request(urlparse.urljoin(trakt_base, url), post=post, headers=headers)
+        return result
+    except:
+        pass
+
+
+def authTrakt(url, post, headers):
+    try:
+        result = client.request(url, post=post, headers=headers)
+        return json.loads(result)['token']
+    except:
+        pass
+
+
+def getTraktCredentials():
+    user = control.setting('trakt_user') 
+    password = control.setting('trakt_password')
+    if (user == '' or password == ''): return False
+    return (user, password)
+
+
+def getTraktAddonMovieInfo():
+    try: scrobble = control.addon('script.trakt').getSetting('scrobble_movie')
+    except: scrobble = ''
+    try: ExcludeHTTP = control.addon('script.trakt').getSetting('ExcludeHTTP')
+    except: ExcludeHTTP = ''
+    try: authorization = control.addon('script.trakt').getSetting('authorization')
+    except: authorization = ''
+    if scrobble == 'true' and ExcludeHTTP == 'false' and not authorization == '': return True
+    else: return False
+
+
+def getTraktAddonEpisodeInfo():
+    try: scrobble = control.addon('script.trakt').getSetting('scrobble_episode')
+    except: scrobble = ''
+    try: ExcludeHTTP = control.addon('script.trakt').getSetting('ExcludeHTTP')
+    except: ExcludeHTTP = ''
+    try: authorization = control.addon('script.trakt').getSetting('authorization')
+    except: authorization = ''
+    if scrobble == 'true' and ExcludeHTTP == 'false' and not authorization == '': return True
+    else: return False
+
+
+def manager(name, imdb, tvdb, content):
+    try:
+        user, password = getTraktCredentials()
+        post = {"movies": [{"ids": {"imdb": imdb}}]} if content == 'movie' else {"shows": [{"ids": {"tvdb": tvdb}}]}
+
+        items = [(control.lang(30472).encode('utf-8'), '/sync/collection')]
+        items += [(control.lang(30473).encode('utf-8'), '/sync/collection/remove')]
+        items += [(control.lang(30474).encode('utf-8'), '/sync/watchlist')]
+        items += [(control.lang(30475).encode('utf-8'), '/sync/watchlist/remove')]
+        items += [(control.lang(30476).encode('utf-8'), '/users/%s/lists/%s/items' % (user, '%s'))]
+
+        result = getTrakt('/users/%s/lists' % user)
+        result = json.loads(result)
+        lists = [(i['name'], i['ids']['slug']) for i in result]
+        lists = [lists[i//2] for i in range(len(lists)*2)]
+        for i in range(0, len(lists), 2):
+            lists[i] = ((control.lang(30477) + ' ' + lists[i][0]).encode('utf-8'), '/users/%s/lists/%s/items' % (user, lists[i][1]))
+        for i in range(1, len(lists), 2):
+            lists[i] = ((control.lang(30478) + ' ' + lists[i][0]).encode('utf-8'), '/users/%s/lists/%s/items/remove' % (user, lists[i][1]))
+        items += lists
+
+        select = control.selectDialog([i[0] for i in items], control.lang(30471).encode('utf-8'))
+
+        if select == -1:
+            return
+        elif select == 4:
+            t = control.lang(30476).encode('utf-8')
+            k = control.keyboard('', t) ; k.doModal()
+            new = k.getText() if k.isConfirmed() else None
+            if (new == None or new == ''): return
+            url = '/users/%s/lists' % user
+            result = getTrakt('/users/%s/lists' % user, post={"name": new, "privacy": "private"})
+
+            try: slug = json.loads(result)['ids']['slug']
+            except: return control.infoDialog('Failed', heading=name)
+            result = getTrakt(items[select][1] % slug, post=post)
+        else:
+            result = getTrakt(items[select][1], post=post)
+
+        info = 'Successful' if not result == None else 'Failed'
+        control.infoDialog(info, heading=name)
+    except:
+        return
+
+
+def syncMovies(timeout=0):
+    try:
+        user, password = getTraktCredentials()
+        return cache.get(getTrakt, timeout, '/users/%s/watched/movies' % user, table='rel_trakt')
+    except:
+        pass
+
+
+def syncTVShows(timeout=0):
+    try:
+        user, password = getTraktCredentials()
+        return cache.get(getTrakt, timeout, '/users/%s/watched/shows?extended=full' % user, table='rel_trakt')
+    except:
+        pass
+
+
+def markMovieAsWatched(imdb):
+    if not imdb.startswith('tt'): imdb = 'tt' + imdb
+    return getTrakt('/sync/history', {"movies": [{"ids": {"imdb": imdb}}]})
+
+
+def markMovieAsNotWatched(imdb):
+    if not imdb.startswith('tt'): imdb = 'tt' + imdb
+    return getTrakt('/sync/history/remove', {"movies": [{"ids": {"imdb": imdb}}]})
+
+
+def markTVShowAsWatched(tvdb):
+    return getTrakt('/sync/history', {"shows": [{"ids": {"tvdb": tvdb}}]})
+
+
+def markTVShowAsNotWatched(tvdb):
+    return getTrakt('/sync/history/remove', {"shows": [{"ids": {"tvdb": tvdb}}]})
+
+
+def markEpisodeAsWatched(tvdb, season, episode):
+    season, episode = int('%01d' % int(season)), int('%01d' % int(episode))
+    return getTrakt('/sync/history', {"shows": [{"seasons": [{"episodes": [{"number": episode}], "number": season}], "ids": {"tvdb": tvdb}}]})
+
+
+def markEpisodeAsNotWatched(tvdb, season, episode):
+    season, episode = int('%01d' % int(season)), int('%01d' % int(episode))
+    return getTrakt('/sync/history/remove', {"shows": [{"seasons": [{"episodes": [{"number": episode}], "number": season}], "ids": {"tvdb": tvdb}}]})
+
+
+def getMovieSummary(id):
+    return getTrakt('/movies/%s' % id)
+
+
+def getTVShowSummary(id):
+    return getTrakt('/shows/%s' % id)
+
+
Index: plugin.video.specto/resources/lib/libraries/gui_utils.py
===================================================================
--- plugin.video.specto/resources/lib/libraries/gui_utils.py	(revision )
+++ plugin.video.specto/resources/lib/libraries/gui_utils.py	(revision )
@@ -1,114 +0,0 @@
-import xbmcgui
-import time
-import os
-import xbmcaddon
-#from utilities import notification, setSetting, getString
-#import traktapi
-import logging
-import control
-from trakt_api2 import TraktAPI2
-
-#__addon__ = xbmcaddon.Addon("script.trakt")
-
-def get_pin():
-    AUTH_BUTTON = 200
-    LATER_BUTTON = 201
-    NEVER_BUTTON = 202
-    ACTION_PREVIOUS_MENU = 10
-    ACTION_BACK = 92
-    INSTRUCTION_LABEL = 203
-    CENTER_Y = 6
-    CENTER_X = 2
-
-    logger = logging.getLogger(__name__)
-    
-    class PinAuthDialog(xbmcgui.WindowXMLDialog):
-        auth = False
-        
-        def onInit(self):
-            self.pin_edit_control = self.__add_editcontrol(30, 240, 40, 450)
-            self.setFocus(self.pin_edit_control)
-            auth = self.getControl(AUTH_BUTTON)
-            never = self.getControl(NEVER_BUTTON)
-            #instuction = self.getControl(INSTRUCTION_LABEL)
-            #instuction.setLabel( "1) " + control.lang(32159).encode('utf-8').format("[COLOR red]http://trakt.tv/pin/999[/COLOR]") + "\n2) " + control.lang(32160).encode('utf-8') + "\n3) " + control.lang(32161).encode('utf-8') + "\n\n" + control.lang(32162).encode('utf-8'))
-            self.pin_edit_control.controlUp(never)
-            self.pin_edit_control.controlLeft(never)
-            self.pin_edit_control.controlDown(auth)
-            self.pin_edit_control.controlRight(auth)
-            auth.controlUp(self.pin_edit_control)
-            auth.controlLeft(self.pin_edit_control)
-            never.controlDown(self.pin_edit_control)
-            never.controlRight(self.pin_edit_control)
-            
-        def onAction(self, action):
-            if action == ACTION_PREVIOUS_MENU or action == ACTION_BACK:
-                self.close()
-
-        def onControl(self, control2):
-            pass
-
-        def onFocus(self, control2):
-            pass
-
-        def onClick(self, control2):
-            print 'onClick: %s' % (control2)
-            if control2 == AUTH_BUTTON:
-                if not self.__get_token():
-                    control.infoDialog('Trakt PIN Authorization Failed.', 'Trakt ERROR')
-                    return
-                self.auth = True
-                self.close()
-
-            if control2 == LATER_BUTTON:
-                control.infoDialog(control.lang(32157) + control.lang(32150))
-                control.set_setting('last_reminder', str(int(time.time())))
-
-            if control == NEVER_BUTTON:
-                control.infoDialog(control.lang(32157) + control.lang(32151))
-                control.set_setting('last_reminder', '-1')
-
-            if control in [AUTH_BUTTON, LATER_BUTTON, NEVER_BUTTON]:
-                self.close()
-        
-        def __get_token(self):
-            pin = self.pin_edit_control.getText().strip()
-            print("PIN",pin)
-            if pin:
-                try:
-                    trakt_api = TraktAPI2(use_https=False, timeout=300)
-                    result = trakt_api.get_token(pin=pin)
-                    print("---",result)
-                    control.set_setting('trakt_oauth_token', result['access_token'])
-                    control.set_setting('trakt_refresh_token', result['refresh_token'])
-                    TOKEN = result['access_token']
-                    trakt_api = TraktAPI2(TOKEN, use_https=False, timeout=300)
-                    profile = trakt_api.get_user_profile(cached=False)
-                    print("Profile",profile)
-                    print("Profile",profile['username'])
-                    control.set_setting('trakt_user', profile['username'])
-                    control.infoDialog('Trakt Authorization Success !', 'Trakt Success')
-
-                    return True
-                except Exception as e:
-                    print('Trakt Authorization Failed: %s') % (e)
-                    control.infoDialog('Trakt Authorization Failed: '+str(e), 'Trakt ERROR')
-                    return False
-            return False
-        
-        # have to add edit controls programatically because getControl() (hard) crashes XBMC on them
-        def __add_editcontrol(self, x, y, height, width):
-            media_path = os.path.join(control.addonPath, 'resources', 'skins', 'Default', 'media')
-            temp = xbmcgui.ControlEdit(0, 0, 0, 0, '', font='font12', textColor='0xFFFFFFFF', focusTexture=os.path.join(media_path, 'button-focus2.png'),
-                                       noFocusTexture=os.path.join(media_path, 'button-nofocus.png'), _alignment=CENTER_Y | CENTER_X)
-            temp.setPosition(x, y)
-            temp.setHeight(height)
-            temp.setWidth(width)
-            self.addControl(temp)
-            return temp
-    #dialog = PinAuthDialog(os.path.join(control.addonPath, 'resources', 'media', 'trakt', 'script-trakt-PinAuthDialog.xml'), control.addonPath)
-    dialog = PinAuthDialog('TraktPinAuthDialog.xml',os.path.join(control.addonPath))
-    dialog.doModal()
-    if dialog.auth:
-        control.infoDialog(control.lang(32157), control.lang(32152), 3000)
-    del dialog
Index: plugin.video.specto/resources/lib/libraries/trakt_api2.py
===================================================================
--- plugin.video.specto/resources/lib/libraries/trakt_api2.py	(revision )
+++ plugin.video.specto/resources/lib/libraries/trakt_api2.py	(revision )
@@ -1,497 +0,0 @@
-"""
-    SALTS XBMC Addon
-    Copyright (C) 2014 tknorris
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-"""
-import json
-import urllib2
-import urllib
-import socket
-import ssl
-import time
-import control
-import re
-#import kodi
-#import log_utils
-#import utils2
-#from db_utils import DB_Connection
-#from constants import TRAKT_SECTIONS
-TEMP_ERRORS = [500, 502, 503, 504, 520, 521, 522, 524]
-
-#from constants import SECTIONS
-
-
-
-class TraktError(Exception):
-    pass
-
-class TraktAuthError(Exception):
-    pass
-
-class TraktNotFoundError(Exception):
-    pass
-
-class TransientTraktError(Exception):
-    pass
-
-BASE_URL = 'api-v2launch.trakt.tv'
-V2_API_KEY = '41cc25669cf6974588f04131b72f7821037ccb5e7e23345c7c1e974b80b9f255'
-CLIENT_SECRET = 'cb89a1a5b7febbb0366d7ca272cd78a591d5826ce21455efc15d9bc45ecccd2e'
-REDIRECT_URI = 'urn:ietf:wg:oauth:2.0:oob'
-RESULTS_LIMIT = 10
-HIDDEN_SIZE = 100
-
-class TraktAPI2():
-    def __init__(self, token=None, use_https=False, list_size=RESULTS_LIMIT, timeout=5):
-        self.token = token
-        self.protocol = 'https://' if use_https else 'http://'
-        self.timeout = None if timeout == 0 else timeout
-        self.list_size = list_size
-
-    def get_token(self, pin=None):
-        url = '/oauth/token'
-        data = {'client_id': V2_API_KEY, 'client_secret': CLIENT_SECRET, 'redirect_uri': REDIRECT_URI}
-        if pin:
-            data['code'] = pin
-            data['grant_type'] = 'authorization_code'
-        else:
-            refresh_token = control.setting('trakt_refresh_token')
-            if refresh_token:
-                data['refresh_token'] = refresh_token
-                data['grant_type'] = 'refresh_token'
-            else:
-                raise TraktError('Can not refresh trakt token. Trakt reauthorizion required.')
-            
-        return self.__call_trakt(url, data=data, auth=False, cached=False)
-    
-    def show_list(self, slug, section, username=None, auth=True, cached=True):
-        if not username:
-            username = 'me'
-            cache_limit = self.__get_cache_limit('lists', 'updated_at', cached)
-        else:
-            cache_limit = 1  # cache other user's list for one hour
-
-        url = '/users/%s/lists/%s/items' % (utils2.to_slug(username), slug)
-        params = {'extended': 'full,images'}
-        list_data = self.__call_trakt(url, params=params, auth=auth, cache_limit=cache_limit, cached=cached)
-        return [item[item['type']] for item in list_data if item['type'] == TRAKT_SECTIONS[section][:-1]]
-
-    def show_watchlist(self, section):
-        url = '/users/me/watchlist/%s' % (TRAKT_SECTIONS[section])
-        params = {'extended': 'full,images'}
-        cache_limit = self.__get_cache_limit(TRAKT_SECTIONS[section], 'watchlisted_at', cached=True)
-        response = self.__call_trakt(url, params=params, cache_limit=cache_limit)
-        return [item[TRAKT_SECTIONS[section][:-1]] for item in response]
-
-    def get_list_header(self, slug, username=None, auth=True):
-        if not username: username = 'me'
-        url = '/users/%s/lists/%s' % (utils2.to_slug(username), slug)
-        return self.__call_trakt(url, auth=auth)
-
-    def get_lists(self, username=None):
-        if not username:
-            username = 'me'
-            cache_limit = self.__get_cache_limit('lists', 'updated_at', True)
-        else:
-            cache_limit = 0
-        url = '/users/%s/lists' % (utils2.to_slug(username))
-        return self.__call_trakt(url, cache_limit=cache_limit)
-
-    def get_liked_lists(self, page=None, cached=True):
-        url = '/users/likes/lists'
-        params = {'limit': self.list_size}
-        if page: params['page'] = page
-        cache_limit = self.__get_cache_limit('lists', 'liked_at', cached=cached)
-        return self.__call_trakt(url, params=params, cache_limit=cache_limit, cached=cached)
-
-    def add_to_list(self, section, slug, items):
-        return self.__manage_list('add', section, slug, items)
-
-    def add_to_collection(self, section, item):
-        return self.__manage_collection('add', section, item)
-
-    def remove_from_collection(self, section, item):
-        return self.__manage_collection('remove', section, item)
-
-    def set_watched(self, section, item, season='', episode='', watched=True):
-        url = '/sync/history'
-        if not watched: url = url + '/remove'
-        data = self.__make_media_list(section, item, season, episode)
-        return self.__call_trakt(url, data=data, cache_limit=0)
-
-    def remove_from_list(self, section, slug, items):
-        return self.__manage_list('remove', section, slug, items)
-
-    def add_to_watchlist(self, section, items):
-        return self.__manage_watchlist('add', section, items)
-
-    def remove_from_watchlist(self, section, items):
-        return self.__manage_watchlist('remove', section, items)
-
-    def get_trending(self, section, page=None):
-        url = '/%s/trending' % (TRAKT_SECTIONS[section])
-        params = {'extended': 'full,images', 'limit': self.list_size}
-        if page: params['page'] = page
-        response = self.__call_trakt(url, params=params)
-        return [item[TRAKT_SECTIONS[section][:-1]] for item in response]
-
-    def get_popular(self, section, page=None):
-        url = '/%s/popular' % (TRAKT_SECTIONS[section])
-        params = {'extended': 'full,images', 'limit': self.list_size}
-        if page: params['page'] = page
-        return self.__call_trakt(url, params=params)
-
-    def get_recent(self, section, date, page=None):
-        url = '/%s/updates/%s' % (TRAKT_SECTIONS[section], date)
-        params = {'extended': 'full,images', 'limit': self.list_size}
-        if page: params['page'] = page
-        response = self.__call_trakt(url, params=params)
-        return [item[TRAKT_SECTIONS[section][:-1]] for item in response]
-
-    def get_most_played(self, section, period, page=None):
-        return self.__get_most('played', section, period, page)
-    
-    def get_most_watched(self, section, period, page=None):
-        return self.__get_most('watched', section, period, page)
-    
-    def get_most_collected(self, section, period, page=None):
-        return self.__get_most('collected', section, period, page)
-    
-    def __get_most(self, category, section, period, page):
-        url = '/%s/%s/%s' % (TRAKT_SECTIONS[section], category, period)
-        params = {'extended': 'full,images', 'limit': self.list_size}
-        if page: params['page'] = page
-        response = self.__call_trakt(url, params=params)
-        return [item[TRAKT_SECTIONS[section][:-1]] for item in response]
-    
-    def get_genres(self, section):
-        url = '/genres/%s' % (TRAKT_SECTIONS[section])
-        return self.__call_trakt(url, cache_limit=7 * 24)
-
-    def get_recommendations(self, section):
-        url = '/recommendations/%s' % (TRAKT_SECTIONS[section])
-        params = {'extended': 'full,images', 'limit': self.list_size}
-        return self.__call_trakt(url, params=params)
-
-    def get_premieres(self, start_date=None, days=None, cached=True):
-        url = '/calendars/all/shows/premieres'
-        if start_date: url += '/%s' % (start_date)
-        if days is not None: url += '/%s' % (days)
-        params = {'extended': 'full,images', 'auth': False}
-        return self.__call_trakt(url, params=params, auth=False, cache_limit=24, cached=cached)
-
-    def get_calendar(self, start_date=None, days=None, cached=True):
-        url = '/calendars/all/shows'
-        if start_date: url += '/%s' % (start_date)
-        if days is not None: url += '/%s' % (days)
-        params = {'extended': 'full,images', 'auth': False}
-        return self.__call_trakt(url, params=params, auth=False, cache_limit=24, cached=cached)
-
-    def get_my_calendar(self, start_date=None, days=None, cached=True):
-        url = '/calendars/my/shows'
-        if start_date: url += '/%s' % (start_date)
-        if days is not None: url += '/%s' % (days)
-        params = {'extended': 'full,images', 'auth': True}
-        return self.__call_trakt(url, params=params, auth=True, cache_limit=24, cached=cached)
-
-    def get_seasons(self, show_id):
-        url = '/shows/%s/seasons' % (show_id)
-        params = {'extended': 'full,images'}
-        return self.__call_trakt(url, params=params, cache_limit=12)
-
-    def get_episodes(self, show_id, season):
-        url = '/shows/%s/seasons/%s' % (show_id, season)
-        params = {'extended': 'full,images'}
-        return self.__call_trakt(url, params=params, cache_limit=1)
-
-    def get_show_details(self, show_id):
-        url = '/shows/%s' % (show_id)
-        params = {'extended': 'full,images'}
-        return self.__call_trakt(url, params=params, cache_limit=24 * 7)
-
-    def get_episode_details(self, show_id, season, episode):
-        url = '/shows/%s/seasons/%s/episodes/%s' % (show_id, season, episode)
-        params = {'extended': 'full,images'}
-        return self.__call_trakt(url, params=params, cache_limit=8)
-
-    def get_movie_details(self, show_id):
-        url = '/movies/%s' % (show_id)
-        params = {'extended': 'full,images'}
-        return self.__call_trakt(url, params=params, cache_limit=8)
-
-    def get_people(self, section, show_id, full=False):
-        url = '/%s/%s/people' % (TRAKT_SECTIONS[section], show_id)
-        params = {'extended': 'full,images'} if full else None
-        try:
-            return self.__call_trakt(url, params=params, cache_limit=24 * 30)
-        except TraktNotFoundError:
-            return {}
-
-    def search(self, section, query, page=None):
-        url = '/search'
-        params = {'type': TRAKT_SECTIONS[section][:-1], 'query': query, 'limit': self.list_size}
-        if page: params['page'] = page
-        # params.update({'extended': 'full,images'})
-        response = self.__call_trakt(url, params=params)
-        return [item[TRAKT_SECTIONS[section][:-1]] for item in response]
-
-    def get_collection(self, section, full=True, cached=True):
-        url = '/users/me/collection/%s' % (TRAKT_SECTIONS[section])
-        params = {'extended': 'full,images'} if full else None
-        media = 'movies' if section == SECTIONS.MOVIES else 'episodes'
-        cache_limit = self.__get_cache_limit(media, 'collected_at', cached)
-        response = self.__call_trakt(url, params=params, cache_limit=cache_limit, cached=cached)
-        result = []
-        for item in response:
-            element = item[TRAKT_SECTIONS[section][:-1]]
-            if section == SECTIONS.TV:
-                element['seasons'] = item['seasons']
-            result.append(element)
-        return result
-
-    def get_watched(self, section, full=False, cached=True):
-        url = '/sync/watched/%s' % (TRAKT_SECTIONS[section])
-        params = {'extended': 'full,images'} if full else None
-        media = 'movies' if section == SECTIONS.MOVIES else 'episodes'
-        cache_limit = self.__get_cache_limit(media, 'watched_at', cached)
-        return self.__call_trakt(url, params=params, cache_limit=cache_limit, cached=cached)
-
-    def get_history(self, section, full=False, page=None, cached=True):
-        url = '/users/me/history/%s' % (TRAKT_SECTIONS[section])
-        params = {'limit': self.list_size}
-        if full: params.update({'extended': 'full,images'})
-        if page: params['page'] = page
-        media = 'movies' if section == SECTIONS.MOVIES else 'episodes'
-        cache_limit = self.__get_cache_limit(media, 'watched_at', cached)
-        return self.__call_trakt(url, params=params, cache_limit=cache_limit, cached=cached)
-
-    def get_show_progress(self, show_id, full=False, hidden=False, specials=False, cached=True, cache_limit=None):
-        if cache_limit is None:
-            cache_limit = self.__get_cache_limit('episodes', 'watched_at', cached)
-        url = '/shows/%s/progress/watched' % (show_id)
-        params = {}
-        if full: params['extended'] = 'full,images'
-        if hidden: params['hidden'] = 'true'
-        if specials: params['specials'] = 'true'
-        return self.__call_trakt(url, params=params, cache_limit=cache_limit, cached=cached)
-
-    def get_hidden_progress(self, cached=True):
-        url = '/users/hidden/progress_watched'
-        params = {'type': 'show', 'limit': HIDDEN_SIZE, 'page': 1}
-        length = -1
-        result = []
-        while length != 0 or length == HIDDEN_SIZE:
-            hidden = self.__call_trakt(url, params=params, cached=cached)
-            length = len(hidden)
-            result += hidden
-            params['page'] += 1
-        return result
-    
-    def get_user_profile(self, username=None, cached=True):
-        if username is None: username = 'me'
-        url = '/users/%s' % (self.to_slug(username))
-        return self.__call_trakt(url, cached=cached)
-        
-    def get_bookmarks(self, section=None, full=False):
-        url = '/sync/playback'
-        if section == SECTIONS.MOVIES:
-            url += '/movies'
-        elif section == SECTIONS.TV:
-            url += '/episodes'
-        params = {'extended': 'full,images'} if full else None
-        return self.__call_trakt(url, params=params, cached=False)
-
-    def get_bookmark(self, show_id, season, episode):
-        response = self.get_bookmarks()
-        for bookmark in response:
-            if not season or not episode:
-                if bookmark['type'] == 'movie' and int(show_id) == bookmark['movie']['ids']['trakt']:
-                    return bookmark['progress']
-            else:
-                # log_utils.log('Resume: %s, %s, %s, %s' % (bookmark, show_id, season, episode), log_utils.LOGDEBUG)
-                if bookmark['type'] == 'episode' and int(show_id) == bookmark['show']['ids']['trakt'] and bookmark['episode']['season'] == int(season) and bookmark['episode']['number'] == int(episode):
-                    return bookmark['progress']
-
-    def delete_bookmark(self, bookmark_id):
-        url = '/sync/playback/%s' % (bookmark_id)
-        return self.__call_trakt(url, method='DELETE', cached=False)
-        
-    def rate(self, section, item, rating, season='', episode=''):
-        url = '/sync/ratings'
-        data = self.__make_media_list(section, item, season, episode)
-
-        if rating is None:
-            url = url + '/remove'
-        else:
-            # method only allows ratings one item at a time, so set rating on first item of each in list
-            if season and episode:
-                data[TRAKT_SECTIONS[section]][0]['seasons'][0]['episodes'][0].update({'rating': int(rating)})
-            elif season:
-                data[TRAKT_SECTIONS[section]][0]['seasons'][0].update({'rating': int(rating)})
-            else:
-                data[TRAKT_SECTIONS[section]][0].update({'rating': int(rating)})
-
-        self.__call_trakt(url, data=data, cache_limit=0)
-
-    def get_last_activity(self, media=None, activity=None):
-        url = '/sync/last_activities'
-        result = self.__call_trakt(url, cache_limit=.01)
-        if media is not None and media in result:
-            if activity is not None and activity in result[media]:
-                return result[media][activity]
-            else:
-                return result[media]
-        
-        return result
-    
-    def __get_cache_limit(self, media, activity, cached):
-        if cached:
-            activity = self.get_last_activity(media, activity)
-            cache_limit = (time.time() - utils2.iso_2_utc(activity))
-            log_utils.log('Now: %s Last: %s Last TS: %s Cache Limit: %.2fs (%.2fh)' % (time.time(), utils2.iso_2_utc(activity), activity, cache_limit, cache_limit / 60 / 60), log_utils.LOGDEBUG)
-            cache_limit = cache_limit / 60 / 60
-        else:
-            cache_limit = 0
-        return cache_limit
-        
-    def __manage_list(self, action, section, slug, items):
-        url = '/users/me/lists/%s/items' % (slug)
-        if action == 'remove': url = url + '/remove'
-        if not isinstance(items, (list, tuple)): items = [items]
-        data = self.__make_media_list_from_list(section, items)
-        return self.__call_trakt(url, data=data, cache_limit=0)
-
-    def __manage_watchlist(self, action, section, items):
-        url = '/sync/watchlist'
-        if action == 'remove': url = url + '/remove'
-        if not isinstance(items, (list, tuple)): items = [items]
-        data = self.__make_media_list_from_list(section, items)
-        return self.__call_trakt(url, data=data, cache_limit=0)
-
-    def __manage_collection(self, action, section, item):
-        url = '/sync/collection'
-        if action == 'remove': url = url + '/remove'
-        data = self.__make_media_list(section, item)
-        return self.__call_trakt(url, data=data, cache_limit=0)
-
-    def __make_media_list(self, section, item, season='', episode=''):
-        ids = {'ids': item}
-        if section == SECTIONS.MOVIES:
-            data = {'movies': [ids]}
-        else:
-            data = {'shows': [ids]}
-            if season:
-                data['shows'][0]['seasons'] = [{'number': int(season)}]
-                if episode:
-                    data['shows'][0]['seasons'][0]['episodes'] = [{'number': int(episode)}]
-        return data
-
-    def to_slug(self,username):
-        username = username.strip()
-        username = username.lower()
-        username = re.sub('[^a-z0-9]', '-', username)
-        return username
-
-    def __make_media_list_from_list(self, section, items):
-        data = {TRAKT_SECTIONS[section]: []}
-        for item in items:
-            ids = {'ids': item}
-            data[TRAKT_SECTIONS[section]].append(ids)
-        return data
-
-    def __call_trakt(self, url, method=None, data=None, params=None, auth=True, cache_limit=.25, cached=True):
-        res_headers = {}
-        #if not cached: cache_limit = 0
-        #db_cache_limit = cache_limit if cache_limit > 8 else 8
-        json_data = json.dumps(data) if data else None
-        headers = {'Content-Type': 'application/json', 'trakt-api-key': V2_API_KEY, 'trakt-api-version': 2}
-        url = '%s%s%s' % (self.protocol, BASE_URL, url)
-        if params: url = url + '?' + urllib.urlencode(params)
-
-        #db_connection = DB_Connection()
-        #created, cached_headers, cached_result = db_connection.get_cached_url(url, json_data, db_cache_limit)
-        #if cached_result and (time.time() - created) < (60 * 60 * cache_limit):
-        #    result = cached_result
-        #    res_headers = dict(cached_headers)
-        #    log_utils.log('Got cached result for: %s' % (url), log_utils.LOGDEBUG)
-        auth_retry = False
-        while True:
-            try:
-                if auth: headers.update({'Authorization': 'Bearer %s' % (self.token)})
-                print('Trakt Call: %s, header: %s, data: %s cache_limit: %s cached: %s') % (url, headers, data, cache_limit, cached)
-                request = urllib2.Request(url, data=json_data, headers=headers)
-                if method is not None: request.get_method = lambda: method.upper()
-                response = urllib2.urlopen(request, timeout=self.timeout)
-                result = ''
-                while True:
-                    data = response.read()
-                    if not data: break
-                    result += data
-                res_headers = dict(response.info().items())
-
-                #db_connection.cache_url(url, result, json_data, response.info().items())
-                break
-            except (ssl.SSLError, socket.timeout) as e:
-                control.infoDialog('Temporary Trakt Error: ' + str(e), "Trakt ERROR")
-                raise TransientTraktError('Temporary Trakt Error: ' + str(e))
-            except urllib2.URLError as e:
-                if isinstance(e, urllib2.HTTPError):
-                    if e.code in TEMP_ERRORS:
-                        control.infoDialog('Temporary Trakt Error: ' + str(e),"Trakt ERROR")
-                        raise TransientTraktError('Temporary Trakt Error: ' + str(e))
-                    elif e.code == 401 or e.code == 405:
-                        # token is fine, profile is private
-                        if e.info().getheader('X-Private-User') == 'true':
-                            control.infoDialog('Object is No Longer Available (%s)' % (e.code),"Trakt ERROR")
-                            raise TraktAuthError('Object is No Longer Available (%s)' % (e.code))
-                        # auth failure retry or a token request
-                        elif auth_retry or url.endswith('/token'):
-                            self.token = None
-                            control.set_setting('trakt_oauth_token', '')
-                            control.set_setting('trakt_refresh_token', '')
-                            control.infoDialog('Trakt Call Authentication Failed (%s)' % (e.code),"Trakt ERROR")
-                            raise TraktAuthError('Trakt Call Authentication Failed (%s)' % (e.code))
-                        # first try token fail, try to refresh token
-                        else:
-                            result = self.get_token()
-                            self.token = result['access_token']
-                            control.set_setting('trakt_oauth_token', result['access_token'])
-                            control.set_setting('trakt_refresh_token', result['refresh_token'])
-                            auth_retry = True
-                    elif e.code == 404:
-                        control.infoDialog('Object Not Found (%s)' % (e.code), "Trakt ERROR")
-                        raise TraktNotFoundError('Object Not Found (%s)' % (e.code))
-                    else:
-                        raise
-                elif isinstance(e.reason, socket.timeout) or isinstance(e.reason, ssl.SSLError):
-                    control.infoDialog('Temporary Trakt Error: ' + str(e),"Trakt ERROR")
-                    raise TransientTraktError('Temporary Trakt Error: ' + str(e))
-                else:
-                    control.infoDialog('Trakt Error: ' + str(e), "Trakt ERROR")
-                    raise TraktError('Trakt Error: ' + str(e))
-            except:
-                raise
-
-        try:
-            js_data = json.loads(result)
-            if 'x-sort-by' in res_headers and 'x-sort-how' in res_headers:
-                js_data = utils2.sort_list(res_headers['x-sort-by'], res_headers['x-sort-how'], js_data)
-        except ValueError:
-            js_data = ''
-            if result:
-                print('Invalid JSON Trakt API Response: %s - |%s|' % (url, js_data))
-
-        print('Trakt Response: %s' % (response))
-        return js_data
Index: plugin.video.specto/resources/lib/libraries/trakt.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/libraries/trakt.py	(revision )
+++ plugin.video.specto/resources/lib/libraries/trakt.py	(revision )
@@ -19,47 +19,122 @@
 '''
 
 
-import json,urlparse,base64
+import json,urlparse,re, time
 
 from resources.lib.libraries import cache
 from resources.lib.libraries import control
 from resources.lib.libraries import client
 
-mytraktkey = 'd4161a7a106424551add171e5470112e4afdaf2438e6ef2fe0548edc75924868'
+mytraktkey = control.trakt_key
 
 def getTrakt(url, post=None):
-    try:
-        trakt_base = 'http://api-v2launch.trakt.tv'
-        #headers = {'Content-Type': 'application/json', 'trakt-api-key': base64.urlsafe_b64decode('ZWI0MWU5NTI0M2Q4Yzk1MTUyZWQ3MmExZmMwMzk0YzkzY2I3ODVjYjMzYWVkNjA5ZmRkZTFhMDc0NTQ1ODRiNA=='), 'trakt-api-version': '2'}
-        headers = {'Content-Type': 'application/json', 'trakt-api-key': 'd4161a7a106424551add171e5470112e4afdaf2438e6ef2fe0548edc75924868', 'trakt-api-version': '2'}
-        user, password = getTraktCredentials()
-        token = cache.get(authTrakt, 24, urlparse.urljoin(trakt_base, '/auth/login'), json.dumps({'login': user, 'password': password}), headers, table='rel_trakt')
-        headers.update({'trakt-user-login': user, 'trakt-user-token': token})
-    except:
-        pass
-    try:
+
+    #try:
+        url = urlparse.urljoin('http://api-v2launch.trakt.tv', url)
+        control.log('My url: %s, post:%s ' % (url,post))
+
+        headers = {'Content-Type': 'application/json', 'trakt-api-key': control.trakt_key, 'trakt-api-version': '2'}
+
         if not post == None: post = json.dumps(post)
-        result = client.request(urlparse.urljoin(trakt_base, url), post=post, headers=headers)
+
+
+        if getTraktCredentialsInfo() == False:
+            result = client.request(url, post=post, headers=headers)
+            control.log('My resuklt: %s, post: %s' % (result, post))
+
-        return result
+            return result
-    except:
-        pass
 
 
-def authTrakt(url, post, headers):
-    try:
+        headers['Authorization'] = 'Bearer %s' % control.setting('trakt.token')
+
+        result = client.request(url, post=post, headers=headers, output='response', error=True)
+        if not (result[0] == '401' or result[0] == '405'): return result[1]
+
+
+        oauth = 'http://api-v2launch.trakt.tv/oauth/token'
+        opost = {'client_id': control.trakt_key, 'client_secret': control.trakt_secret, 'redirect_uri': 'urn:ietf:wg:oauth:2.0:oob', 'grant_type': 'refresh_token', 'refresh_token': control.setting('trakt.refresh')}
+
+        result = client.request(oauth, post=json.dumps(opost), headers=headers)
+        result = json.loads(result)
+
+        token, refresh = result['access_token'], result['refresh_token']
+
+        control.set_setting('trakt.token', token)
+        control.set_setting('trakt.refresh', refresh)
+
+        headers['Authorization'] = 'Bearer %s' % token
+
         result = client.request(url, post=post, headers=headers)
-        return json.loads(result)['token']
+        return result
+    #except:
+    #    pass
+
+
+def authTrakt():
+    try:
+        if getTraktCredentialsInfo() == True:
+            if control.yesnoDialog(control.lang(30479).encode('utf-8'), control.lang(30481).encode('utf-8'), '', 'Trakt', control.lang(30483).encode('utf-8'), control.lang(30482).encode('utf-8')):
+                control.set_setting('trakt.user', '')
+                control.set_setting('trakt.token', '')
+                control.set_setting('trakt.refresh', '')
+            raise Exception()
+
+        result = getTrakt('/oauth/device/code', {'client_id': control.trakt_key})
+        result = json.loads(result)
+        verification_url = (control.lang(30416) + '[COLOR skyblue]%s[/COLOR]' % result['verification_url']).encode('utf-8')
+        user_code = (control.lang(30417) + '[COLOR skyblue]%s[/COLOR]' % result['user_code']).encode('utf-8')
+        expires_in = int(result['expires_in'])
+        device_code = result['device_code']
+        interval = result['interval']
+
+        progressDialog = control.progressDialog
+        progressDialog.create('Trakt', verification_url, user_code)
+
+        for i in range(0, expires_in):
+            try:
+                if progressDialog.iscanceled(): break
+                time.sleep(1)
+                if not float(i) % interval == 0: raise Exception()
+                r = getTrakt('/oauth/device/token', {'client_id': control.trakt_key, 'client_secret': control.trakt_secret, 'code': device_code})
+                r = json.loads(r)
+                if 'access_token' in r: break
-    except:
-        pass
+            except:
+                pass
 
+        try: progressDialog.close()
+        except: pass
 
-def getTraktCredentials():
-    user = control.setting('trakt_user') 
-    password = control.setting('trakt_password')
-    if (user == '' or password == ''): return False
-    return (user, password)
+        token, refresh = r['access_token'], r['refresh_token']
 
+        headers = {'Content-Type': 'application/json', 'trakt-api-key': control.trakt_key, 'trakt-api-version': '2', 'Authorization': 'Bearer %s' % token}
 
+        result = client.request('http://api-v2launch.trakt.tv/users/me', headers=headers)
+        result = json.loads(result)
+
+        user = result['username']
+
+        control.set_setting('trakt.user', user)
+        control.set_setting('trakt.token', token)
+        control.set_setting('trakt.refresh', refresh)
+        raise Exception()
+    except:
+        control.openSettings('3.1')
+
+
+def getTraktCredentialsInfo():
+    user = control.setting('trakt.user').strip()
+    token = control.setting('trakt.token')
+    refresh = control.setting('trakt.refresh')
+    if (user == '' or token == '' or refresh == ''): return False
+    return True
+
+
+def getTraktIndicatorsInfo():
+    indicators = control.setting('indicators') if getTraktCredentialsInfo() == False else control.setting('indicators.alt')
+    indicators = True if indicators == '1' else False
+    return indicators
+
+
 def getTraktAddonMovieInfo():
     try: scrobble = control.addon('script.trakt').getSetting('scrobble_movie')
     except: scrobble = ''
@@ -84,23 +159,22 @@
 
 def manager(name, imdb, tvdb, content):
     try:
-        user, password = getTraktCredentials()
         post = {"movies": [{"ids": {"imdb": imdb}}]} if content == 'movie' else {"shows": [{"ids": {"tvdb": tvdb}}]}
 
         items = [(control.lang(30472).encode('utf-8'), '/sync/collection')]
         items += [(control.lang(30473).encode('utf-8'), '/sync/collection/remove')]
         items += [(control.lang(30474).encode('utf-8'), '/sync/watchlist')]
         items += [(control.lang(30475).encode('utf-8'), '/sync/watchlist/remove')]
-        items += [(control.lang(30476).encode('utf-8'), '/users/%s/lists/%s/items' % (user, '%s'))]
+        items += [(control.lang(30476).encode('utf-8'), '/users/me/lists/%s/items')]
 
-        result = getTrakt('/users/%s/lists' % user)
+        result = getTrakt('/users/me/lists')
         result = json.loads(result)
         lists = [(i['name'], i['ids']['slug']) for i in result]
         lists = [lists[i//2] for i in range(len(lists)*2)]
         for i in range(0, len(lists), 2):
-            lists[i] = ((control.lang(30477) + ' ' + lists[i][0]).encode('utf-8'), '/users/%s/lists/%s/items' % (user, lists[i][1]))
+            lists[i] = ((control.lang(30477) + ' ' + lists[i][0]).encode('utf-8'), '/users/me/lists/%s/items' % lists[i][1])
         for i in range(1, len(lists), 2):
-            lists[i] = ((control.lang(30478) + ' ' + lists[i][0]).encode('utf-8'), '/users/%s/lists/%s/items/remove' % (user, lists[i][1]))
+            lists[i] = ((control.lang(30478) + ' ' + lists[i][0]).encode('utf-8'), '/users/me/lists/%s/items/remove' % lists[i][1])
         items += lists
 
         select = control.selectDialog([i[0] for i in items], control.lang(30471).encode('utf-8'))
@@ -112,8 +186,7 @@
             k = control.keyboard('', t) ; k.doModal()
             new = k.getText() if k.isConfirmed() else None
             if (new == None or new == ''): return
-            url = '/users/%s/lists' % user
-            result = getTrakt('/users/%s/lists' % user, post={"name": new, "privacy": "private"})
+            result = getTrakt('/users/me/lists', post={"name": new, "privacy": "private"})
 
             try: slug = json.loads(result)['ids']['slug']
             except: return control.infoDialog('Failed', heading=name)
@@ -127,22 +200,108 @@
         return
 
 
-def syncMovies(timeout=0):
+def slug(name):
+    name = name.strip()
+    name = name.lower()
+    name = re.sub('[^a-z0-9_]', '-', name)
+    name = re.sub('--+', '-', name)
+    return name
+
+
+def getActivity():
     try:
-        user, password = getTraktCredentials()
-        return cache.get(getTrakt, timeout, '/users/%s/watched/movies' % user, table='rel_trakt')
+        result = getTrakt('/sync/last_activities')
+        i = json.loads(result)
+
+        activity = []
+        activity.append(i['movies']['collected_at'])
+        activity.append(i['episodes']['collected_at'])
+        activity.append(i['movies']['watchlisted_at'])
+        activity.append(i['shows']['watchlisted_at'])
+        activity.append(i['seasons']['watchlisted_at'])
+        activity.append(i['episodes']['watchlisted_at'])
+        activity.append(i['lists']['updated_at'])
+        activity.append(i['lists']['liked_at'])
+        activity = [int(control.cleandate.iso_2_utc(i)) for i in activity]
+        activity = sorted(activity, key=int)[-1]
+
+        return activity
     except:
         pass
 
 
-def syncTVShows(timeout=0):
+def getWatchedActivity():
     try:
-        user, password = getTraktCredentials()
-        return cache.get(getTrakt, timeout, '/users/%s/watched/shows?extended=full' % user, table='rel_trakt')
+        result = getTrakt('/sync/last_activities')
+        i = json.loads(result)
+
+        activity = []
+        activity.append(i['movies']['watched_at'])
+        activity.append(i['episodes']['watched_at'])
+        activity = [int(control.cleandate.iso_2_utc(i)) for i in activity]
+        activity = sorted(activity, key=int)[-1]
+
+        return activity
     except:
         pass
 
 
+def cachesyncMovies(timeout=0):
+    indicators = cache.get(syncMovies, timeout, control.setting('trakt.user').strip(), table='trakt')
+    return indicators
+
+
+def timeoutsyncMovies():
+    timeout = cache.timeout(syncMovies, control.setting('trakt.user').strip(), table='trakt')
+    return timeout
+
+
+def syncMovies(user):
+    try:
+        if getTraktCredentialsInfo() == False: return
+        indicators = getTrakt('/users/me/watched/movies')
+        indicators = json.loads(indicators)
+        indicators = [i['movie']['ids'] for i in indicators]
+        indicators = [str(i['imdb']) for i in indicators if 'imdb' in i]
+        return indicators
+    except:
+        pass
+
+
+def cachesyncTVShows(timeout=0):
+    indicators = cache.get(syncTVShows, timeout, control.setting('trakt.user').strip(), table='trakt')
+    return indicators
+
+
+def timeoutsyncTVShows():
+    timeout = cache.timeout(syncTVShows, control.setting('trakt.user').strip(), table='trakt')
+    return timeout
+
+
+def syncTVShows(user):
+    try:
+        if getTraktCredentialsInfo() == False: return
+        indicators = getTrakt('/users/me/watched/shows?extended=full')
+        indicators = json.loads(indicators)
+        indicators = [(i['show']['ids']['tvdb'], i['show']['aired_episodes'], sum([[(s['number'], e['number']) for e in s['episodes']] for s in i['seasons']], [])) for i in indicators]
+        indicators = [(str(i[0]), int(i[1]), i[2]) for i in indicators]
+        return indicators
+    except:
+        pass
+
+
+def syncSeason(imdb):
+    try:
+        if getTraktCredentialsInfo() == False: return
+        indicators = getTrakt('/shows/%s/progress/watched?specials=false&hidden=false' % imdb)
+        indicators = json.loads(indicators)['seasons']
+        indicators = [(i['number'], [x['completed'] for x in i['episodes']]) for i in indicators]
+        indicators = ['%01d' % int(i[0]) for i in indicators if not False in i[1]]
+        return indicators
+    except:
+        pass
+
+
 def markMovieAsWatched(imdb):
     if not imdb.startswith('tt'): imdb = 'tt' + imdb
     return getTrakt('/sync/history', {"movies": [{"ids": {"imdb": imdb}}]})
@@ -177,5 +336,3 @@
 
 def getTVShowSummary(id):
     return getTrakt('/shows/%s' % id)
-
-
Index: plugin.video.specto/resources/lib/libraries/client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/libraries/client.py	(revision )
+++ plugin.video.specto/resources/lib/libraries/client.py	(revision )
@@ -99,7 +99,9 @@
             request = urllib2.Request(url, headers=headers)
         else:
             request = urllib2.Request(url, urllib.urlencode(post), headers=headers)
-            #control.log("POST DATA %s" % post)
+            #request = urllib2.Request(url, data=post, headers=headers)
+
+            control.log("POST DATA %s" % post)
         try:
             response = urllib2.urlopen(request, timeout=int(timeout))
         except urllib2.HTTPError as response:
\ No newline at end of file
Index: plugin.video.specto/resources/lib/libraries/control.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/lib/libraries/control.py	(revision )
+++ plugin.video.specto/resources/lib/libraries/control.py	(revision )
@@ -21,11 +21,8 @@
 
 import os,xbmc,xbmcaddon,xbmcplugin,xbmcgui,xbmcvfs
 import base64, jsunpack
-import random, time
+import random, time,datetime
 
-tmdb_key = jsunpack.jsunpack_keys()
-tvdb_key = base64.urlsafe_b64decode('MUQ2MkYyRjkwMDMwQzQ0NA==')
-fanarttv_key = base64.urlsafe_b64decode('YTc4YzhmZWRjN2U3NTE1MjRkMzkyNmNhMmQyOTU3OTg=')
 
 scriptID = 'plugin.video.specto'
 ptv = xbmcaddon.Addon(scriptID)
@@ -235,8 +232,14 @@
             a=1
         except: pass  # just give up
 
+tmdb_key = jsunpack.jsunpack_keys()
+tvdb_key = base64.urlsafe_b64decode('MUQ2MkYyRjkwMDMwQzQ0NA==')
+fanarttv_key = base64.urlsafe_b64decode('YTc4YzhmZWRjN2U3NTE1MjRkMzkyNmNhMmQyOTU3OTg=')
+trakt_key = base64.urlsafe_b64decode('NDFjYzI1NjY5Y2Y2OTc0NTg4ZjA0MTMxYjcyZjc4MjEwMzdjY2I1ZTdlMjMzNDVjN2MxZTk3NGI4MGI5ZjI1NQ==')
+trakt_secret = base64.urlsafe_b64decode('Y2I4OWExYTViN2ZlYmJiMDM2NmQ3Y2EyNzJjZDc4YTU5MWQ1ODI2Y2UyMTQ1NWVmYzE1ZDliYzQ1ZWNjY2QyZQ==')
 
 
+
 def randomagent():
     BR_VERS = [
         ['%s.0' % i for i in xrange(18, 43)],
@@ -279,3 +282,42 @@
     else:
         user_agent = setting('current_ua')
     return user_agent
+
+
+
+def iso_2_utc(iso_ts):
+    if not iso_ts or iso_ts is None: return 0
+    delim = -1
+    if not iso_ts.endswith('Z'):
+        delim = iso_ts.rfind('+')
+        if delim == -1: delim = iso_ts.rfind('-')
+
+    if delim > -1:
+        ts = iso_ts[:delim]
+        sign = iso_ts[delim]
+        tz = iso_ts[delim + 1:]
+    else:
+        ts = iso_ts
+        tz = None
+
+    if ts.find('.') > -1:
+        ts = ts[:ts.find('.')]
+
+    try: d = datetime.datetime.strptime(ts, '%Y-%m-%dT%H:%M:%S')
+    except TypeError: d = datetime.datetime(*(time.strptime(ts, '%Y-%m-%dT%H:%M:%S')[0:6]))
+
+    dif = datetime.timedelta()
+    if tz:
+        hours, minutes = tz.split(':')
+        hours = int(hours)
+        minutes = int(minutes)
+        if sign == '-':
+            hours = -hours
+            minutes = -minutes
+        dif = datetime.timedelta(minutes=minutes, hours=hours)
+    utc_dt = d - dif
+    epoch = datetime.datetime.utcfromtimestamp(0)
+    delta = utc_dt - epoch
+    try: seconds = delta.total_seconds()  # works only on 2.7
+    except: seconds = delta.seconds + delta.days * 24 * 3600  # close enough
+    return seconds
Index: plugin.video.specto/resources/settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/resources/settings.xml	(revision )
+++ plugin.video.specto/resources/settings.xml	(revision )
@@ -139,9 +139,10 @@
 		<setting id="host50020" type="select" label="30900" values="-|180upload|Allmyvideos|Allvid|Animeultima|Bestreams|Clicknupload|Cloudtime|Cloudzilla|Daclips|Divxpress|Dizibox|Dizimag|Exashare|Faststream|Fastvideo|Filehoot|Filenuke|Filepup|Gorillavid|GVideo|Grifthost|Ipithos|iShared|Letwatch|Mailru|Mightyupload|Movdivx|Moviefarsi|Movpod|Movshare|Mrfile|MVsnap|Nosvideo|Novamov|Nowvideo|Openload|Ororo|Primeshare|Promptfile|Putstream|Realvid|Sharerepo|Sharesix|Skyvids|StageVu|Streamcloud|Streamin|Thefile|Thevideo|Turbovideos|Tusfiles|Up2stream|Uploadc|Uptobox|V-vids|Vidbull|Videoweed|Vidlockers|Vidspot|Vidto|Vidzi|VK|Vodlocker|Xvidstage|Youtube|Zalaa|Zettahost|zStream" default="zStream" />
 	</category>
 	<category label="30910">
-		<!--<setting type="lsep" label="Trakt" />
-		<setting id="trakt_user" type="text" label="30911" default="" />
-		<setting id="trakt_password" type="text" option="hidden" label="30913" default="" />-->
+		<setting type="lsep" label="Trakt" />
+		<setting id="trakt.user" type="action" label="30914" option="close" action="RunPlugin(plugin://plugin.video.specto/?action=authTrakt)" />
+		<setting id="trakt.token" type="text" option="hidden" visible="false" label="" default="" />
+		<setting id="trakt.refresh" type="text" option="hidden" visible="false" label="" default="" />
 		<setting type="lsep" label="IMDb" />
 		<setting id="imdb_user" type="text" label="30911" default="" />
 		<setting type="lsep" label="Alluc (accounts.alluc.com)" />
@@ -184,10 +185,12 @@
 		<setting id="check_movie_link" type="bool" label="30928" default="false" />
 		<setting id="check_episode_link" type="bool" label="30929" default="false" />
 	</category>
+
 	<category label="30950">
-		<setting id="movie_downloads" type="folder" label="30951" default="special://userdata/addon_data/plugin.video.specto/Downloads/Movies" />
-		<setting id="tv_downloads" type="folder" label="30952" default="special://userdata/addon_data/plugin.video.specto/Downloads/TVShows" />
+		<setting id="movie_downloads" type="folder" label="30951" default="" />
+		<setting id="tv_downloads" type="folder" label="30952" default="" />
 	</category>
+
 	<category label="30940">
 		<setting id="subtitles" type="bool" label="30943" default="false" />
 		<setting type="sep" />
@@ -198,16 +201,7 @@
 		<setting type="lsep" label="[CR]" />
 		<setting type="lsep" label="30941" />
 		<setting type="lsep" label="30942" />
-	</category>
-	<category label="30208">
-        <setting id="get_pin" label="31174" type="action" action="RunPlugin(plugin://plugin.video.specto/?action=traktpinauth)" option="close" visible="True"/>
-        <setting id="trakt_user" label="30911" type="text" visible="True"/>
-        <setting id="use_https" type="bool" label="31175" default="false"/>
-        <setting id="trakt_timeout" type="slider" label="31176" default="30" range="0,120" option="int"/>
-        <setting id="trakt_oauth_token" type="text" default="" visible="false"/>
-        <setting id="trakt_refresh_token" type="text" default="" visible="false"/>
-        <setting id="trakt_refresh_time" type="number" default="0" visible="false"/>
-    </category>
+	</category>
 
 	<setting id="current_ua" type="text" visible="false"/>
     <setting id="last_ua_create" type="number" default="0" visible="false"/>
Index: plugin.video.specto/default.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/default.py	(revision )
+++ plugin.video.specto/default.py	(revision )
@@ -26,6 +26,10 @@
 import urlparse,sys
 from resources.lib.libraries import control
 
+
+import pydevd
+pydevd.settrace(stdoutToServer=True, stderrToServer=True)
+
 params = dict(urlparse.parse_qsl(sys.argv[2].replace('?','')))
 control.log("->----------                PARAMS: %s" % params)
 
@@ -130,9 +134,9 @@
     from resources.lib.resolvers.realdebrid import rdAuthorize
     rdAuthorize()
 
-elif action == 'traktpinauth':
-    from resources.lib.indexers import navigator
-    navigator.navigator().trakt_pin_auth()
+elif action == 'authTrakt':
+    from resources.lib.libraries import trakt
+    trakt.authTrakt()
 
 elif action == 'movieNavigator':
     from resources.lib.indexers import navigator
Index: plugin.video.specto/changelog.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- plugin.video.specto/changelog.txt	(revision )
+++ plugin.video.specto/changelog.txt	(revision )
@@ -4,6 +4,7 @@
 Fix scraper - beter handling cloudflare for 1080p sites
 Added Sources:
     - Pelispedia
+    - rainierland
 
 ------------------------
 Specto v2016.04.20.1
